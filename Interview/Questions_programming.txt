#include<iostream>
#include<stdio.h>
 
using namespace std;
 
class Base
{
public:
  Base()
  {
    fun(); //note: fun() is virtual
  }
  virtual void fun()
  {
    cout<<"\nBase Function";
  }
};
 
class Derived: public Base
{
public:
  Derived(){}
  virtual void fun()
  {
    cout<<"\nDerived Function";
  }
};
 
int main()
{
  Base* pBase = new Derived();
  delete pBase;
  return 0;
}

Output: 
Base Function

//-----------------------------------------------------

#include<iostream>
using namespace std;
  
int x = 10;
void fun()
{
    int x = 2;
    {
        int x = 1;
        cout << ::x << endl; 
    }
}
  
int main()
{
    fun();
    return 0;
}
Output: 10

//-----------------------------------------------------

#include<iostream>
using namespace std;
  
class Point {
private:
    int x;
    int y;
public:
    Point(int i = 0, int j = 0);    // Normal Constructor
    Point(const Point &t); // Copy Constructor
};
  
Point::Point(int i, int j)  {
    x = i;
    y = j;
    cout << "Normal Constructor called\n";
}
  
Point::Point(const Point &t) {
   y = t.y;
   cout << "Copy Constructor called\n";
}
  
int main()
{
   Point *t1, *t2;
   t1 = new Point(10, 15);
   t2 = new Point(*t1);
   Point t3 = *t1;
   Point t4;
   t4 = t3;
   return 0;
}
Output:
Normal Constructor called
Copy Constructor called
Copy Constructor called
Normal Constructor called

//-----------------------------------------------------
Please explain this code 

#include<iostream>
using namespace std;
class P
{
public:
	P() {
		cout << "P Constructor called\n";
	}
    virtual void show() = 0;
};
  
class Q : public P { 
   int x;
public:
   Q() {
		cout << "Q Constructor called\n";
	}
};
  
int main(void)
{
    Q q;
    return 0;
}
Output: Compiler Error

//-----------------------------------------------------------------
#include<iostream>
  
using namespace std;
class Base1 {
 public:
     Base1()
     { cout << " Base1's constructor called" << endl;  }
};
  
class Base2 {
 public:
     Base2()
     { cout << "Base2's constructor called" << endl;  }
};
  
class Derived: public Base1, public Base2 {
   public:
     Derived()
     {  cout << "Derived's constructor called" << endl;  }
};
  
int main()
{
   Derived d;
   return 0;
}

// ------------------------------------------------------
#include<iostream>
  
using namespace std;
  
class Test {
    int &t;
public:
    Test (int &x) { t = x; }
    int getT() { return t; }
};
  
int main()
{
    int x = 20;
    Test t1(x);
    cout << t1.getT() << " ";
    x = 30;
    cout << t1.getT() << endl;
    return 0;
}
Output: Compiler Error
Since t is a reference in Test, it must be initialized using Initializer List. 
Following is the modified program. It works and prints “20 30”.

// ----------------------------------------------------------
#include <iostream>
using namespace std;
  
class Fraction
{
private:
    int den;
    int num;
public:
   void print() { cout << num << "/" << den; }
   Fraction() { num = 1; den = 1; }
   int &Den() { return den; }
   int &Num() { return num; }
};
  
int main()
{
   Fraction f1;
   f1.Num() = 7;
   f1.Den() = 9;
   f1.print();
   return 0;
}

// --------------------------------------------------------
#include<iostream>
using namespace std;
  
class A
{
    // data members of A
public:
    A ()           { cout << "\n A's constructor"; /* Initialize data members */ }
    A (const A &a) { cout << "\n A's Copy constructor";  /* copy data members */}
    A& operator= (const A &a) // Assignment Operator
    {
        cout << "\n A's Assignment Operator";  return *this;
    }
};
  
class B
{
    A a;
    // Other members of B
public:
    B(A &a) { this->a = a; cout << "\n B's constructor"; }
};
  
int main()
{
    A a1;
    B b(a1);
    return 0;
}

Output:

 A's constructor
 A's constructor
 A's Assignment Operator
 B's constructor
 
// ----------------------------------------------------
#include <iostream>
using namespace std;
  
class A
{
    int id;
public:
    A (int i) { id = i; }
    void print () { cout << id << endl; }
};
  
int main()
{
    A a[2];
    a[0].print();
    a[1].print();
    return 0;
}

There is a compilation error in line “A a[2]”. 
There is no default constructor in class A. When we write our own parameterzied constructor or copy constructor,
compiler doesn’t create the default constructor

// ---------------------------------------------------------------
#include<iostream>
using namespace std;
  
class Test
{
    int value;
public:
    Test(int v = 0) { value = v; }
    int getValue()  { return value; }
};
  
int main()
{
    const Test t;
    cout << t.getValue();
    return 0;
}
Output: Compiler Error
In the above program, object ‘t’ is declared as a const object. 
A const object can only call const functions. To fix the error, we must make getValue() a const function

//------------------------------------------------------------
#include<iostream>
using namespace std;
  
class Base 
{
public:
    int fun()      { cout << "Base::fun() called"; }
    int fun(int i) { cout << "Base::fun(int i) called"; }
};
  
class Derived: public Base 
{
public:
    int fun(char x)   { cout << "Derived::fun(char ) called"; }
};
  
int main() 
{
    Derived d;
    d.fun();
    return 0;
}
Output: Compiler Error.
In the above program, fun() of base class is not accessible in the derived class. 
If a derived class creates a member method with name same as one of the methods in base class, 
then all the base class methods with this name become hidden in derived class

// ---------------------------------------------------------------
#include<iostream>
using namespace std;
class Base 
{
   protected:
      int x;
   public:
      Base (int i){ x = i;}
};
  
class Derived : public Base 
{
   public:
      Derived (int i):x(i) { }
      void print() { cout << x ; }
};
  
int main()
{
    Derived d(10);
    d.print();
}
Output: Compiler Error
In the above program, x is protected, so it is accessible in derived class.
Derived class constructor tries to use initializer list to directly initialize x, which is not allowed even if x is accessible.
The members of base class can only be initialized through a constructor call of base class.

// -------------------------------------------------------------------
